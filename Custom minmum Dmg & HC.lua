--Working on aimware
--Inspiration from bkt.lua
--Part of the code comes from forums and GitHub
--[[Credit
@Network cache and require --Yukine https://aimware.net/forum/user/366321
@write file --Chicken4676 https://aimware.net/forum/user/17687
]]
--Producers by qi

--region aw api
--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua
--I only made a little change to make him work for aimware
local entities_GetPlayerResources, entities_FindByClass, entities_GetByIndex, entities_GetLocalPlayer, entities_GetByUserID =
    entities.GetPlayerResources,
    entities.FindByClass,
    entities.GetByIndex,
    entities.GetLocalPlayer,
    entities.GetByUserID
local client_GetLocalPlayerIndex,
    client_ChatSay,
    client_WorldToScreen,
    client_Command,
    client_GetPlayerIndexByUserID,
    client_SetConVar,
    client_GetPlayerInfo,
    client_GetConVar =
    client.GetLocalPlayerIndex,
    client.ChatSay,
    client.WorldToScreen,
    client.Command,
    client.GetPlayerIndexByUserID,
    client.SetConVar,
    client.GetPlayerInfo,
    client.GetConVar
local client_GetPlayerNameByIndex, client_GetPlayerNameByUserID, client_ChatTeamSay, client_AllowListener =
    client.GetPlayerNameByIndex,
    client.GetPlayerNameByUserID,
    client.ChatTeamSay,
    client.AllowListener
local globals_FrameTime,
    globals_AbsoluteFrameTime,
    globals_CurTime,
    globals_TickCount,
    globals_MaxClients,
    globals_RealTime,
    globals_FrameCount,
    globals_TickInterval =
    globals.FrameTime,
    globals.AbsoluteFrameTime,
    globals.CurTime,
    globals.TickCount,
    globals.MaxClients,
    globals.RealTime,
    globals.FrameCount,
    globals.TickInterval
local http_Get = http.Get
local math_ceil,
    math_tan,
    math_huge,
    math_log10,
    math_randomseed,
    math_cos,
    math_sinh,
    math_random,
    math_mod,
    math_pi,
    math_max,
    math_atan2,
    math_ldexp,
    math_floor,
    math_sqrt,
    math_deg,
    math_atan =
    math.ceil,
    math.tan,
    math.huge,
    math.log10,
    math.randomseed,
    math.cos,
    math.sinh,
    math.random,
    math.mod,
    math.pi,
    math.max,
    math.atan2,
    math.ldexp,
    math.floor,
    math.sqrt,
    math.deg,
    math.atan
local math_fmod,
    math_acos,
    math_pow,
    math_abs,
    math_min,
    math_log,
    math_frexp,
    math_sin,
    math_tanh,
    math_exp,
    math_modf,
    math_cosh,
    math_asin,
    math_rad =
    math.fmod,
    math.acos,
    math.pow,
    math.abs,
    math.min,
    math.log,
    math.frexp,
    math.sin,
    math.tanh,
    math.exp,
    math.modf,
    math.cosh,
    math.asin,
    math.rad
local table_foreach, table_sort, table_remove, table_foreachi, table_maxn, table_getn, table_concat, table_insert =
    table.foreach,
    table.sort,
    table.remove,
    table.foreachi,
    table.maxn,
    table.getn,
    table.concat,
    table.insert
local string_find,
    string_lower,
    string_format,
    string_rep,
    string_gsub,
    string_len,
    string_gmatch,
    string_dump,
    string_match,
    string_reverse,
    string_byte,
    string_char,
    string_upper,
    string_gfind,
    string_sub =
    string.find,
    string.lower,
    string.format,
    string.rep,
    string.gsub,
    string.len,
    string.gmatch,
    string.dump,
    string.match,
    string.reverse,
    string.byte,
    string.char,
    string.upper,
    string.gfind,
    string.sub
--endregion

--inspect
--@file check and download come from Chicken4676 https://aimware.net/forum/user/17687
local imagepack_lib_installed = false
file.Enumerate(
    function(filename)
        if filename == "libraries/imagepack_icons.lua" then
            imagepack_lib_installed = true
        end
    end
)
if not imagepack_lib_installed then
    http_Get(
        "https://raw.githubusercontent.com/287871/aimware/main/imagepack_icons.lua",
        function(ctx) --Network cache from Yukine
            file.Write("libraries/imagepack_icons.lua", ctx)
            network_error = ctx
        end
    )
end
--endregion

--region require
--@require come from Yukine https://aimware.net/forum/user/366321
local function require(filename)
    local require_inspect_file = false
    file.Enumerate(
        function(filename_inspect)
            if filename_inspect == filename .. ".lua" then
                require_inspect_file = true
            end
        end
    )
    if not require_inspect_file then
        error(filename .. ".lua library is required")
        return
    end
    local res = file.Open(filename .. ".lua", "r")
    if res then
        local buf = res:Read()
        res:Close()
        return loadstring(buf)()
    end
    return nil
end
local function waiting_download()
    if not pcall(gui.GetValue, "rbot.accuracy.custom.hicdmg.ind") then
        if network_error == "error" then
            draw.Color(255, 0, 0, 255)
            draw.Text(0, 0, GetScriptName() .. "  Can't link to github")
        elseif not pcall(require, "libraries/imagepack_icons") then
            draw.Color(255, 255, 255, 255)
            draw.Text(0, 0, GetScriptName() .. "  Please wait to download the icon library")
        else
            draw.Color(34, 170, 74, 255)
            draw.Text(0, 0, GetScriptName() .. "  Download successfully, please reload")
        end
    end
    return
end
callbacks.Register("Draw", waiting_download)

local csgo_weapons = require "libraries/imagepack_icons"
--endregion

--region menu_weapon
--@return matching weapon naem
local function menu_weapon(var)
    local wp = string_match(var, [["(.+)"]])
    local wp = string_lower(wp)
    if wp == "heavy pistol" then
        return "hpistol"
    elseif wp == "auto sniper" then
        return "asniper"
    elseif wp == "submachine gun" then
        return "smg"
    elseif wp == "light machine gun" then
        return "lmg"
    else
        return wp
    end
end
--endregion

--region gui
local reference = gui.Reference("Ragebot", "Accuracy", "Weapon")
local reference2 = gui.Reference("Ragebot", "Accuracy")
local custom_hd_misc = gui.Groupbox(reference2, "Custom Hit Chance & Min Damage", 329, 440, 296, 0)

--Framework from Zerdos -let me do it in less code
local ui = {
    wp_var = {"shared", "zeus", "pistol", "hpistol", "smg", "rifle", "shotgun", "scout", "asniper", "sniper", "lmg"},
    hitchance = {enable = {}, ove_key = {}, default = {}, override = {}, inair = {}},
    mindmg = {enable = {}, ove_key = {}, visible = {}, autowall = {}, override = {}, inair = {}}
}
local function for_gui()
    local checkbox = gui.Checkbox
    local slider = gui.Slider
    for i = 1, 11 do
        --- Hit chance
        ui.hitchance.enable[ui.wp_var[i]] = checkbox(custom_hd_misc, "custom." .. ui.wp_var[i] .. ".hitchance", "Hit Chance", 0)
        ui.hitchance.ove_key[ui.wp_var[i]] = checkbox(custom_hd_misc, "custom." .. ui.wp_var[i] .. ".hitchance.key", "Hit Chance Override Key", 0)
        ui.hitchance.default[ui.wp_var[i]] = slider(reference, "custom." .. ui.wp_var[i] .. ".hitchance.default", "Hit Chance [Default]", 50, 0, 100)
        ui.hitchance.override[ui.wp_var[i]] =
            slider(reference, "custom." .. ui.wp_var[i] .. ".hitchance.override", "Hit Chance [Override]", 50, 0, 100)
        ui.hitchance.inair[ui.wp_var[i]] = slider(reference, "custom." .. ui.wp_var[i] .. ".hitchance.inair", "Hit Chance [inAir]", 50, 0, 100)
        --- damage
        ui.mindmg.enable[ui.wp_var[i]] = checkbox(custom_hd_misc, "custom." .. ui.wp_var[i] .. ".mindmg", "Min Damage", 0)
        ui.mindmg.ove_key[ui.wp_var[i]] = checkbox(custom_hd_misc, "custom." .. ui.wp_var[i] .. ".hmindmg.key", "Min Damage Override Key", 0)
        ui.mindmg.visible[ui.wp_var[i]] = slider(reference, "custom." .. ui.wp_var[i] .. ".mindmg.visible", "Min Damage [Visible]", 50, 1, 130)
        ui.mindmg.autowall[ui.wp_var[i]] = slider(reference, "custom." .. ui.wp_var[i] .. ".mindmg.autowall", "Min Damage [Autowall]", 50, 1, 130)
        ui.mindmg.override[ui.wp_var[i]] = slider(reference, "custom." .. ui.wp_var[i] .. ".mindmg.override", "Min Damage [Override]", 50, 1, 130)
        ui.mindmg.inair[ui.wp_var[i]] = slider(reference, "custom." .. ui.wp_var[i] .. ".mindmg.inair", "Min Damage [inAir]", 50, 1, 130)
    end
end
for_gui()
local x, y = draw.GetScreenSize()
local custom_hd_ind = gui.Checkbox(custom_hd_misc, "custom.hicdmg.ind", "indicator", 1)
local custom_hd_ind_rgb = gui.Checkbox(custom_hd_ind, "rgb", "rgb", 0)
local custom_hd_ind_clr = gui.ColorPicker(custom_hd_ind, "clr", "clr", 131, 109, 221, 255)
local custom_hd_ind_clr2 = gui.ColorPicker(custom_hd_ind, "clr2", "clr2", 255, 255, 255, 255)
local custom_hd_ind_clr3 = gui.ColorPicker(custom_hd_ind, "clr3", "clr3", 0, 0, 0, 100)

local ind_x = gui.Slider(custom_hd_ind, "x", "x", x * 0.1, 0, x)
local ind_y = gui.Slider(custom_hd_ind, "y", "y", y * 0.35, 0, y)

--set invisible
custom_hd_ind_rgb:SetInvisible(true)
ind_x:SetInvisible(true)
ind_y:SetInvisible(true)
local function gui_set_invisible()
    local weapon = menu_weapon(reference:GetValue())
    local hitchance = gui.GetValue("rbot.accuracy.custom." .. weapon .. ".hitchance")
    local mindmg = gui.GetValue("rbot.accuracy.custom." .. weapon .. ".mindmg")

    local ind = custom_hd_ind:GetValue()
    custom_hd_ind_clr:SetInvisible(not ind)
    custom_hd_ind_clr2:SetInvisible(not ind)
    custom_hd_ind_clr3:SetInvisible(not ind)

    if gui.GetValue("rbot.accuracy.movement.slowkey") ~= 0 then
        custom_hd_misc:SetPosY(440)
    else
        custom_hd_misc:SetPosY(378)
    end

    for i = 1, 11 do
        ui.hitchance.enable[ui.wp_var[i]]:SetInvisible(true)
        ui.hitchance.ove_key[ui.wp_var[i]]:SetInvisible(true)
        ui.hitchance.default[ui.wp_var[i]]:SetInvisible(true)
        ui.hitchance.override[ui.wp_var[i]]:SetInvisible(true)
        ui.hitchance.inair[ui.wp_var[i]]:SetInvisible(true)

        ui.mindmg.enable[ui.wp_var[i]]:SetInvisible(true)
        ui.mindmg.ove_key[ui.wp_var[i]]:SetInvisible(true)
        ui.mindmg.visible[ui.wp_var[i]]:SetInvisible(true)
        ui.mindmg.autowall[ui.wp_var[i]]:SetInvisible(true)
        ui.mindmg.override[ui.wp_var[i]]:SetInvisible(true)
        ui.mindmg.inair[ui.wp_var[i]]:SetInvisible(true)
    end

    ui.hitchance.enable[weapon]:SetInvisible(false)
    ui.hitchance.ove_key[weapon]:SetInvisible(not hitchance)
    ui.hitchance.default[weapon]:SetInvisible(not hitchance)
    ui.hitchance.override[weapon]:SetInvisible(not hitchance)
    ui.hitchance.inair[weapon]:SetInvisible(not hitchance)

    ui.mindmg.enable[weapon]:SetInvisible(false)
    ui.mindmg.ove_key[weapon]:SetInvisible(not mindmg)
    ui.mindmg.visible[weapon]:SetInvisible(not mindmg)
    ui.mindmg.autowall[weapon]:SetInvisible(not mindmg)
    ui.mindmg.override[weapon]:SetInvisible(not mindmg)
    ui.mindmg.inair[weapon]:SetInvisible(not mindmg)
end
callbacks.Register("Draw", gui_set_invisible)
--endregion

--region renderer
local renderer = {}
renderer.rectangle = function(x, y, w, h, clr, fill, radius)
    local alpha = 255

    if clr[4] ~= nil then
        alpha = clr[4]
    end

    draw.Color(clr[1], clr[2], clr[3], alpha)

    if fill then
        draw.FilledRect(x, y, x + w, y + h)
    else
        draw.OutlinedRect(x, y, x + w, y + h)
    end

    if fill == "shadow" then
        draw.ShadowRect(x, y, x + w, y + h, radius)
    end

    alpha = nil
end
renderer.gradient = function(x, y, w, h, clr, clr1, vertical)
    local r, g, b, a = clr1[1], clr1[2], clr1[3], clr1[4]
    local r1, g1, b1, a1 = clr[1], clr[2], clr[3], clr[4]

    if a and a1 == nil then
        a, a1 = 255, 255
    end

    if vertical then
        if clr[4] ~= 0 then
            if a1 and a ~= 255 then
                for i = 0, w do
                    local a2 = i / w * a1
                    renderer.rectangle(x, y + w - i, w, 1, {r1, g1, b1, a2}, true)
                end
            else
                renderer.rectangle(x, y, w, h, {r1, g1, b1, a1}, true)
            end
        end
        if a2 ~= 0 then
            for i = 0, h do
                local a2 = i / h * a
                renderer.rectangle(x, y + i, w, 1, {r, g, b, a2}, true)
            end
        end
    else
        if clr[4] ~= 0 then
            if a1 and a ~= 255 then
                for i = 0, w do
                    local a2 = i / w * a1
                    renderer.rectangle(x + w - i, y, 1, h, {r1, g1, b1, a2}, true)
                end
            else
                renderer.rectangle(x, y, w, h, {r1, g1, b1, a1}, true)
            end
        end
        if a2 ~= 0 then
            for i = 0, w do
                local a2 = i / w * a
                renderer.rectangle(x + i, y, 1, h, {r, g, b, a2}, true)
            end
        end
    end
    a, a1 = nil, nil
end
--endregion

--region mouse drag
local menu = gui.Reference("Menu")
local chd_move_x, chd_move_y, chd_offset_x, chd_offset_y, chd_drag
local function is_inside(a, b, x, y, w, h)
    return a >= x and a <= w and b >= y and b <= h
end
local function drag_indicator(x, y, w, h)
    if not menu:IsActive() then
        return chd_move_x, chd_move_y
    end
    local mouse_down = input.IsButtonDown(1)
    if mouse_down then
        local mouse_x, mouse_y = input.GetMousePos()
        if not chd_drag then
            local w, h = x + w, y + h
            if is_inside(mouse_x, mouse_y, x, y, w, h) then
                chd_offset_x = mouse_x - x
                chd_offset_y = mouse_y - y
                chd_drag = true
            end
        else
            chd_move_x = mouse_x - chd_offset_x
            chd_move_y = mouse_y - chd_offset_y
            ind_x:SetValue(chd_move_x)
            ind_y:SetValue(chd_move_y)
        end
    else
        chd_drag = false
    end
    return chd_move_x, chd_move_y
end
--endregion

--region RGB gradient contrast effect
--- Come from https://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
--- a little modification made him work for lua
--- Converts an HSL color value to RGB. Conversion formula
--- adapted from http://en.wikipedia.org/wiki/HSL_color_space.
--- Assumes h, s, and l are contained in the set [0, 1] and
--- returns r, g, and b in the set [0, 255].
---
---@param   Number  h       The hue
---@param   Number  s       The saturation
---@param   Number  l       The lightness
---@return  Array           The RGB representation
local function hslToRgb(h, s, l)
    local r, g, b

    if (s == 0) then
        r = l
        g = l
        b = l -- achromatic
    else
        local function hue2rgb(p, q, t)
            if (t < 0) then
                t = t + 1
            end
            if (t > 1) then
                t = t - 1
            end
            if (t < 1 / 6) then
                return p + (q - p) * 6 * t
            end
            if (t < 1 / 2) then
                return q
            end
            if (t < 2 / 3) then
                return p + (q - p) * (2 / 3 - t) * 6
            end
            return p
        end

        local q = 0
        if (l < 0.5) then
            q = l * (1 + s)
        else
            q = l + s - l * s
        end

        local p = 2 * l - q

        r = hue2rgb(p, q, h + 1 / 3)
        g = hue2rgb(p, q, h)
        b = hue2rgb(p, q, h - 1 / 3)
    end

    return {r * 255, g * 255, b * 255}
end

--endregion

--region simple stop
local function clamp(val, min, max)
    if (val > max) then
        return max
    elseif (val < min) then
        return min
    else
        return val
    end
end
--endregion

--region hitchance
local function hitchance()
    local lp = entities_GetLocalPlayer()
    local weapon = menu_weapon(reference:GetValue())

    if gui.GetValue("rbot.accuracy.custom." .. weapon .. ".hitchance") then
        if gui.GetValue("rbot.accuracy.custom." .. weapon .. ".hitchance.key") then
            local override_hc = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".hitchance.override")
            gui.SetValue("rbot.accuracy.weapon." .. weapon .. ".hitchance", override_hc)
        else
            local default_hc = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".hitchance.default")
            gui.SetValue("rbot.accuracy.weapon." .. weapon .. ".hitchance", default_hc)
        end

        if lp then
            local flags = lp:GetPropInt("m_fFlags")
            if bit.band(flags, 1) == 0 then
                local inair_hc = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".hitchance.inair")
                gui.SetValue("rbot.accuracy.weapon." .. weapon .. ".hitchance", inair_hc)
            end
        end
    end
end
--endregion

--region min damage
--Check for visibility
local function entities_check()
    local lp = entities_GetLocalPlayer()
    local abs_o
    if lp then
        abs_o = lp:GetAbsOrigin()
        if (math_floor((lp:GetPropInt("m_fFlags") % 4) / 2) == 1) then
            z = 46
        else
            z = 64
        end
        abs_o.z = abs_o.z + lp:GetPropVector("localdata", "m_vecViewOffset[0]").z
        return abs_o, lp
    end
end

local function is_vis(LocalPlayerPos)
    local is_vis = false
    local players = entities.FindByClass("CCSPlayer")
    local fps = 4
    for i, player in pairs(players) do
        if player:GetTeamNumber() ~= entities_GetLocalPlayer():GetTeamNumber() and player:IsPlayer() and entities_check() ~= nil and player:IsAlive() then
            for i = 0, 4 do
                for x = 0, fps do
                    local v = player:GetHitboxPosition(i)

                    if x == 0 then
                        v.x = v.x
                        v.y = v.y
                    elseif x == 1 then
                        v.x = v.x
                        v.y = v.y + 4
                    elseif x == 2 then
                        v.x = v.x
                        v.y = v.y - 4
                    elseif x == 3 then
                        v.x = v.x + 4
                        v.y = v.y
                    elseif x == 4 then
                        v.x = v.x - 4
                        v.y = v.y
                    end

                    local c = (engine.TraceLine(LocalPlayerPos, v, 0x1)).contents
                    if c == 0 then
                        is_vis = true
                        break
                    end
                end
            end
        end
    end
    return is_vis
end

--set min damage
local function mindamage()
    local lp = entities_GetLocalPlayer()
    local weapon = menu_weapon(reference:GetValue())
    local player = entities_check()

    if gui.GetValue("rbot.accuracy.custom." .. weapon .. ".mindmg") then
        if is_vis(player) then
            local vis_dmg = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.visible")
            gui.SetValue("rbot.accuracy.weapon." .. weapon .. ".mindmg", vis_dmg)
        else
            local autowall_dmg = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.autowall")
            gui.SetValue("rbot.accuracy.weapon." .. weapon .. ".mindmg", autowall_dmg)
        end

        if gui.GetValue("rbot.accuracy.custom." .. weapon .. ".hmindmg.key") then
            local override_dmg = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.override")
            gui.SetValue("rbot.accuracy.weapon." .. weapon .. ".mindmg", override_dmg)
        end

        if lp then
            local flags = lp:GetPropInt("m_fFlags")
            if bit.band(flags, 1) == 0 then
                local inair_dmg = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.inair")
                gui.SetValue("rbot.accuracy.weapon." .. weapon .. ".mindmg", inair_dmg)
            end
        end
    end
end
--endregion

--region draw ind
--let drag position save
local function position_save()
    if chd_move_x ~= ind_x:GetValue() or chd_move_y ~= ind_y:GetValue() then
        chd_move_x = ind_x:GetValue()
        chd_move_y = ind_y:GetValue()
    end
end
--on draw ind

--background
local function background(x, y, w, h, clr, _rgb)
    local gradient = renderer.gradient
    local r, g, b, a = clr[1], clr[2], clr[3], clr[4]
    local rgb = hslToRgb((globals.CurTime() / clamp(100 - 90, 1, 100)) % 1, 1, 0.5)
    draw.Color(r, g, b, a)
    draw.FilledRect(x, y, x + w, y + h)
    if _rgb then
        gradient(x, y, w - 1, h, {rgb[1], rgb[2], rgb[3], a}, {rgb[2], rgb[3], rgb[1], a}, false)
    end
end

--region decoding svg
---@create texture
local function CreateTexture(svg)
    return draw.CreateTexture(common.RasterizeSVG(svg))
end
--endregion

--region simple stop
local function clamp(val, min, max)
    if (val > max) then
        return max
    elseif (val < min) then
        return min
    else
        return val
    end
end
--endregion

--region weapon id
local weapon_id = {
    [1] = CreateTexture(csgo_weapons["deagle"][3]),
    [2] = CreateTexture(csgo_weapons["elite"][3]),
    [3] = CreateTexture(csgo_weapons["fiveseven"][3]),
    [4] = CreateTexture(csgo_weapons["glock"][3]),
    [7] = CreateTexture(csgo_weapons["ak47"][3]),
    [8] = CreateTexture(csgo_weapons["aug"][3]),
    [9] = CreateTexture(csgo_weapons["awp"][3]),
    [10] = CreateTexture(csgo_weapons["famas"][3]),
    [11] = CreateTexture(csgo_weapons["g3sg1"][3]),
    [13] = CreateTexture(csgo_weapons["galilar"][3]),
    [14] = CreateTexture(csgo_weapons["m249"][3]),
    [16] = CreateTexture(csgo_weapons["m4a1"][3]),
    [17] = CreateTexture(csgo_weapons["mac10"][3]),
    [19] = CreateTexture(csgo_weapons["p90"][3]),
    [23] = CreateTexture(csgo_weapons["mp5sd"][3]),
    [24] = CreateTexture(csgo_weapons["ump45"][3]),
    [25] = CreateTexture(csgo_weapons["xm1014"][3]),
    [26] = CreateTexture(csgo_weapons["bizon"][3]),
    [27] = CreateTexture(csgo_weapons["mag7"][3]),
    [28] = CreateTexture(csgo_weapons["negev"][3]),
    [29] = CreateTexture(csgo_weapons["sawedoff"][3]),
    [30] = CreateTexture(csgo_weapons["tec9"][3]),
    [31] = CreateTexture(csgo_weapons["taser"][3]),
    [32] = CreateTexture(csgo_weapons["hkp2000"][3]),
    [33] = CreateTexture(csgo_weapons["mp7"][3]),
    [34] = CreateTexture(csgo_weapons["mp9"][3]),
    [35] = CreateTexture(csgo_weapons["nova"][3]),
    [36] = CreateTexture(csgo_weapons["p250"][3]),
    [38] = CreateTexture(csgo_weapons["scar20"][3]),
    [39] = CreateTexture(csgo_weapons["sg556"][3]),
    [40] = CreateTexture(csgo_weapons["ssg08"][3]),
    [41] = CreateTexture(csgo_weapons["knifegg"][3]),
    [42] = CreateTexture(csgo_weapons["knife"][3]),
    [43] = CreateTexture(csgo_weapons["flashbang"][3]),
    [44] = CreateTexture(csgo_weapons["hegrenade"][3]),
    [45] = CreateTexture(csgo_weapons["smokegrenade"][3]),
    [46] = CreateTexture(csgo_weapons["molotov"][3]),
    [47] = CreateTexture(csgo_weapons["decoy"][3]),
    [48] = CreateTexture(csgo_weapons["incgrenade"][3]),
    [49] = CreateTexture(csgo_weapons["c4"][3]),
    [59] = CreateTexture(csgo_weapons["knife"][3]),
    [60] = CreateTexture(csgo_weapons["m4a1_silencer"][3]),
    [61] = CreateTexture(csgo_weapons["usp_silencer"][3]),
    [63] = CreateTexture(csgo_weapons["cz75a"][3]),
    [64] = CreateTexture(csgo_weapons["revolver"][3]),
    [500] = CreateTexture(csgo_weapons["bayonet"][3]),
    [505] = CreateTexture(csgo_weapons["knife_flip"][3]),
    [506] = CreateTexture(csgo_weapons["knife_gut"][3]),
    [507] = CreateTexture(csgo_weapons["knife_karambit"][3]),
    [508] = CreateTexture(csgo_weapons["knife_m9_bayonet"][3]),
    [509] = CreateTexture(csgo_weapons["knife_tactical"][3]),
    [512] = CreateTexture(csgo_weapons["knife_falchion"][3]),
    [514] = CreateTexture(csgo_weapons["knife_bowie"][3]),
    [515] = CreateTexture(csgo_weapons["knife_butterfly"][3]),
    [516] = CreateTexture(csgo_weapons["knife_push"][3]),
    [519] = CreateTexture(csgo_weapons["knife_ursus"][3]),
    [520] = CreateTexture(csgo_weapons["knife_gypsy_jackknife"][3]),
    [522] = CreateTexture(csgo_weapons["knife_stiletto"][3]),
    [523] = CreateTexture(csgo_weapons["knife_widowmaker"][3]),
    [524] = CreateTexture(csgo_weapons["knife_t"][3])
}

local function get_weapon_name(entity)
    if not entity then
        return
    end
    local active_weapon = entity:GetPropEntity("m_hActiveWeapon")
    if not active_weapon:GetName() then
        return
    end
    local name = string.match(active_weapon:GetName(), [[weapon_(.+)]])
    return name
end

--text_shadow
local function text_shadow(x, y, string, clr)
    local r, g, b, a = clr[1], clr[2], clr[3], clr[4]
    draw.Color(4, 4, 4, a)
    draw.Text(x + 1, y + 1, string)
    draw.Color(r, g, b, a)
    draw.Text(x, y, string)
end

--return mode
local function hd_mode()
    local weapon = menu_weapon(reference:GetValue())

    local hitchance_text
    local hitchance = gui.GetValue("rbot.accuracy.weapon." .. weapon .. ".hitchance")
    local hitchance_def = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".hitchance.default")
    local hitchance_ove = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".hitchance.override")
    local hitchance_air = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".hitchance.inair")

    if hitchance == hitchance_def then
        hitchance_text = "[default]"
    elseif hitchance == hitchance_ove then
        hitchance_text = "[override]"
    elseif hitchance == hitchance_air then
        hitchance_text = "[in air]"
    else
        hitchance_text = "[default]"
    end

    local mindmg_text
    local mindmg = gui.GetValue("rbot.accuracy.weapon." .. weapon .. ".mindmg")
    local mindmg_vis = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.visible")
    local mindmg_aw = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.autowall")
    local mindmg_ove = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.override")
    local mindmg_air = gui.GetValue("rbot.accuracy.weapon.custom." .. weapon .. ".mindmg.inair")

    if mindmg == mindmg_vis then
        mindmg_text = "[visible]"
    elseif mindmg == mindmg_aw then
        mindmg_text = "[auto wall]"
    elseif mindmg == mindmg_ove then
        mindmg_text = "[override]"
    elseif mindmg == mindmg_air then
        mindmg_text = "[in air]"
    else
        mindmg_text = "[auto wall]"
    end
    return {hitchance_text, mindmg_text}
end

--ind
local font = draw.CreateFont("Verdana", 12)
local function on_ind(x, y, alpha, weapon)
    local rgb = custom_hd_ind_rgb:GetValue()
    local hitchance = gui.GetValue("rbot.accuracy.weapon." .. weapon .. ".hitchance")
    local hitchance_mode = hd_mode()[1]

    local mindmg = gui.GetValue("rbot.accuracy.weapon." .. weapon .. ".mindmg")
    local mindmg_mode = hd_mode()[2]

    local r, g, b, a_ = custom_hd_ind_clr3:GetValue()
    draw.Color(r, g, b, a_ * alpha / 255)
    draw.FilledRect(x, y + 2, x + 150, y + 18)

    local r, g, b, a = custom_hd_ind_clr:GetValue()
    if a_ ~= 0 then
        background(x, y, 150, 2, {r, g, b, a * alpha / 255}, rgb)
    end

    background(x + 10, y + 52, mindmg * 1.04, 2, {r, g, b, a * 0.4 * alpha / 255}, rgb)
    background(x + 10, y + 35, hitchance * 1.25, 2, {r, g, b, a * 0.4 * alpha / 255}, rgb)

    draw.Color(r, g, b, a * alpha / 255)
    draw.FilledRect(x + 2, y + 20, x + 4, y + 35)
    draw.FilledRect(x + 2, y + 37, x + 4, y + 52)

    local r, g, b, a = custom_hd_ind_clr2:GetValue()

    draw.SetFont(font)
    local hc_mode_w = draw.GetTextSize(hitchance_mode)
    if a_ ~= 0 then
        text_shadow(x + 52, y + 5, "htc & dmg", {r, g, b, a * alpha / 255})
    end
    text_shadow(x + 6, y + 24, "hit chance:" .. hitchance .. "%", {r, g, b, a * alpha / 255})
    text_shadow(x + 145 - hc_mode_w, y + 24, hitchance_mode, {r, g, b, a * alpha / 255})

    local dmg_mode_w = draw.GetTextSize(mindmg_mode)
    text_shadow(x + 6, y + 40, "min dmg:" .. ((mindmg > 100) and ("hp+" .. (mindmg - 100)) or mindmg), {r, g, b, a * alpha / 255})
    text_shadow(x + 145 - dmg_mode_w, y + 40, mindmg_mode, {r, g, b, a * alpha / 255})
end

--Icon
local function on_Icon(x, y, alpha, entity, weapon)
    if not entity then
        return
    end
    local wp_name = get_weapon_name(entity)
    local wid = entity:GetWeaponID()
    if not wid then
        return
    end

    local r, g, b, a = custom_hd_ind_clr:GetValue()
    draw.Color(r, g, b, a * alpha / 255)
    draw.FilledRect(x + 2, y + 54, x + 4, y + 69)

    local r, g, b, a = custom_hd_ind_clr2:GetValue()
    text_shadow(x + 6, y + 56, "weapon:", {r, g, b, a * alpha / 255})
    draw.SetTexture(weapon_id[wid])
    draw.FilledRect(x + 50, y + 56, (x + 50) + csgo_weapons[wp_name][1] * 0.4, (y + 56) + csgo_weapons[wp_name][2] * 0.4)
    draw.SetTexture(nil)
    local menu_wp_w = draw.GetTextSize("[" .. weapon .. "]")
    text_shadow(x + 145 - menu_wp_w, y + 56, "[" .. weapon .. "]", {r, g, b, a * alpha / 255})
end

--on draw
local function on_draw(x, y, alpha, alpha2, entity)
    local weapon = menu_weapon(reference:GetValue())
    if alpha ~= 0 then
        on_ind(x, y, alpha, weapon)
    end
    if alpha2 ~= 0 then
        on_Icon(x, y, alpha2, entity, weapon)
    end
end
--endregion

--region callbacks
local c_hcdmg_alpha = 0
local c_hcdmg_alpha2 = 0

callbacks.Register(
    "Draw",
    function()
        hitchance()
        mindamage()
        local lp = entities_GetLocalPlayer()
        local fade_factor = ((1.0 / 0.15) * globals_FrameTime()) * 250
        if lp and custom_hd_ind:GetValue() then
            c_hcdmg_alpha = clamp(c_hcdmg_alpha + fade_factor, 0, 255)
        else
            c_hcdmg_alpha = clamp(c_hcdmg_alpha - fade_factor, 0, 255)
        end
        if lp and lp:IsAlive() and custom_hd_ind:GetValue() then
            c_hcdmg_alpha2 = clamp(c_hcdmg_alpha2 + fade_factor, 0, 255)
        else
            c_hcdmg_alpha2 = clamp(c_hcdmg_alpha2 - fade_factor, 0, 255)
        end

        if c_hcdmg_alpha or c_hcdmg_alpha2 ~= 0 then
            position_save()
            local x, y = drag_indicator(chd_move_x, chd_move_y, 150, 75)
            on_draw(x, y, c_hcdmg_alpha, c_hcdmg_alpha2, lp)
        end
    end
)
--endregion
